<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Manual · HalfIntegers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>HalfIntegers.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href="">Manual</a><ul class="internal"><li><a class="toctext" href="#Half-integer-types-1">Half-integer types</a></li><li><a class="toctext" href="#Construction-of-HalfIntegers-1">Construction of <code>HalfInteger</code>s</a></li><li><a class="toctext" href="#Arithmetic-operations-1">Arithmetic operations</a></li><li><a class="toctext" href="#Auxiliary-functions-1">Auxiliary functions</a></li><li><a class="toctext" href="#Wraparound-behavior-1">Wraparound behavior</a></li><li><a class="toctext" href="#Custom-HalfInteger-types-1">Custom <code>HalfInteger</code> types</a></li></ul></li><li><a class="toctext" href="../api/">API documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Manual</a></li></ul><a class="edit-page" href="https://github.com/sostock/HalfIntegers.jl/blob/master/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Manual-1" id="Manual-1">Manual</a></h1><h2><a class="nav-anchor" href="#Half-integer-types-1" id="Half-integer-types-1">Half-integer types</a></h2><div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In this package, any number <span>$\frac{n}{2}$</span> where <span>$n\in\mathbb{Z}$</span> is considered a half-integer – contrary to the common definition, <span>$n$</span> does not have to be odd, i.e., the integers are a subset of the half-integers.</p></div></div><p>The abstract type <code>HalfInteger &lt;: Real</code> is provided as a supertype for all half-integer types. Concrete half-integer types are provided in the form of the parametric type <code>Half{T} &lt;: HalfInteger</code> where <code>T</code> can be any <code>Integer</code> type. The type <code>Half{T}</code> can represent any number <code>n/2</code> where <code>n</code> is of type <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; Half{Int}(5//2)
5/2

julia&gt; Half{Int8}(3)
3

julia&gt; ans isa HalfInteger
true

julia&gt; typemin(Half{Int8}), typemax(Half{Int8})
(-64, 127/2)</code></pre><p>For convenient use, aliases for <code>Half{T}</code> exist for all standard integer types <code>T</code> defined in Julia (except for <code>Bool</code>). For example, <code>HalfInt</code> can be used instead of <code>Half{Int}</code>:</p><pre><code class="language-julia-repl">julia&gt; HalfInt(3.5)
7/2

julia&gt; typeof(ans) # Half{Int32} or Half{Int64} depending on on system word size
Half{Int64}</code></pre><p>The following aliases are defined:</p><table><tbody><tr><th style="text-align: left"><code>T</code></th><th style="text-align: left">Alias for <code>Half{T}</code></th></tr><tr><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>HalfInt</code></td></tr><tr><td style="text-align: left"><code>Int8</code></td><td style="text-align: left"><code>HalfInt8</code></td></tr><tr><td style="text-align: left"><code>Int16</code></td><td style="text-align: left"><code>HalfInt16</code></td></tr><tr><td style="text-align: left"><code>Int32</code></td><td style="text-align: left"><code>HalfInt32</code></td></tr><tr><td style="text-align: left"><code>Int64</code></td><td style="text-align: left"><code>HalfInt64</code></td></tr><tr><td style="text-align: left"><code>Int128</code></td><td style="text-align: left"><code>HalfInt128</code></td></tr><tr><td style="text-align: left"><code>BigInt</code></td><td style="text-align: left"><code>BigHalfInt</code> (<em>not</em><code>HalfBigInt</code>!)</td></tr><tr><td style="text-align: left"><code>UInt</code></td><td style="text-align: left"><code>HalfUInt</code></td></tr><tr><td style="text-align: left"><code>UInt8</code></td><td style="text-align: left"><code>HalfUInt8</code></td></tr><tr><td style="text-align: left"><code>UInt16</code></td><td style="text-align: left"><code>HalfUInt16</code></td></tr><tr><td style="text-align: left"><code>UInt32</code></td><td style="text-align: left"><code>HalfUInt32</code></td></tr><tr><td style="text-align: left"><code>UInt64</code></td><td style="text-align: left"><code>HalfUInt64</code></td></tr><tr><td style="text-align: left"><code>UInt128</code></td><td style="text-align: left"><code>HalfUInt128</code></td></tr></tbody></table><h2><a class="nav-anchor" href="#Construction-of-HalfIntegers-1" id="Construction-of-HalfIntegers-1">Construction of <code>HalfInteger</code>s</a></h2><p><code>HalfInteger</code>s can be created from any other number type using constructors or <code>convert</code>:</p><pre><code class="language-julia-repl">julia&gt; HalfUInt(5.5)
11/2

julia&gt; convert(BigHalfInt, 3//2)
3/2

julia&gt; convert(Complex{HalfInt}, 2.5 + 3.5im)
5/2 + 7/2*im</code></pre><p>Alternatively, one can use the <code>half</code> function, which halves its argument and returns an appropriate <code>HalfInteger</code> or <code>Complex{&lt;:HalfInteger}</code> type:</p><pre><code class="language-julia-repl">julia&gt; half(3)
3/2

julia&gt; half(4.0)
2

julia&gt; half(3 - 4im)
3/2 - 2*im</code></pre><p>Note that the argument must be an integer value (or a complex value with integer real and imaginary parts), but does not need to be of an <code>Integer</code> or <code>Complex{&lt;:Integer}</code> type. An optional argument can be used to specify the return type, which must be <code>&lt;:HalfInteger</code> or <code>&lt;:Complex{&lt;:HalfInteger}</code>:</p><pre><code class="language-julia-repl">julia&gt; half(BigHalfInt, -11)
-11/2

julia&gt; half(Complex{HalfInt}, 4+1im)
2 + 1/2*im</code></pre><p>Calling the <code>Half</code> constructor without type parameter is disallowed to avoid confusion with the <code>half</code> function.</p><h2><a class="nav-anchor" href="#Arithmetic-operations-1" id="Arithmetic-operations-1">Arithmetic operations</a></h2><p>The provided half-integer types support all common arithmetic operations. For operations between different types, the values are promoted to an appropriate type:</p><pre><code class="language-julia-repl">julia&gt; HalfInt(1/2) + HalfInt(5)
11/2

julia&gt; HalfInt(1/2) + 5
11/2

julia&gt; HalfInt(1/2) + 5.0
5.5

julia&gt; complex(HalfInt(1/2)) + 5//1
11//2 + 0//1*im</code></pre><p>Since the product of two half-integers is not a half-integer (unless one of them is actually an integer), multiplication of two <code>HalfInteger</code>s result in a floating-point number. Multiplication of a <code>HalfInteger</code> and an <code>Integer</code> yields another <code>HalfInteger</code>:</p><pre><code class="language-julia-repl">julia&gt; HalfInt(1/2) * HalfInt(7/2)
1.75

julia&gt; HalfInt(1/2) * HalfInt(5)
2.5

julia&gt; HalfInt(1/2) * 5
5/2</code></pre><p>Dividing two half-integers result in a floating-point number as well, but rational and Euclidean division are defined as well:</p><pre><code class="language-julia-repl">julia&gt; HalfInt(7/2) / HalfInt(3/2)
2.3333333333333335

julia&gt; HalfInt(7/2) // HalfInt(3/2)
7//3

julia&gt; HalfInt(7/2) ÷ HalfInt(3/2)
2</code></pre><h2><a class="nav-anchor" href="#Auxiliary-functions-1" id="Auxiliary-functions-1">Auxiliary functions</a></h2><h3><a class="nav-anchor" href="#twice-1" id="twice-1"><code>twice</code></a></h3><p>The <code>twice</code> function can be regarded as the inverse of the <code>half</code> function: it doubles its argument. However, in contrast to <code>half</code>, which always returns a <code>HalfInteger</code> or <code>Complex{&lt;:HalfInteger}</code>, <code>twice</code> only returns an <code>Integer</code> when the argument is a <code>HalfInteger</code> or an <code>Integer</code>. Alternatively, the return type of <code>twice</code> can be specified with an optional first argument:</p><pre><code class="language-julia-repl">julia&gt; twice(HalfInt32(5/2)) # returns an Int32
5

julia&gt; twice(3.5)            # returns a Float64
7.0

julia&gt; twice(Integer, 3.5)   # returns an Int
7</code></pre><p>Furthermore, while <code>half</code> only accepts integer values (or complex values with integer components), the argument of <code>twice</code> may have any numeric value:</p><pre><code class="language-julia-repl">julia&gt; twice(3//8)
3//4

julia&gt; half(ans)
ERROR: InexactError: Integer(3//4)</code></pre><h3><a class="nav-anchor" href="#onehalf-1" id="onehalf-1"><code>onehalf</code></a></h3><p>Analogous to <code>zero</code> and <code>one</code>, the function <code>onehalf</code> returns the value 1/2 in the specified type (the argument may be a value of the desired type or the type itself):</p><pre><code class="language-julia-repl">julia&gt; onehalf(HalfInt)
1/2

julia&gt; onehalf(big"2.0")
0.50

julia&gt; onehalf(7//3)
1//2</code></pre><h3><a class="nav-anchor" href="#ishalfinteger-1" id="ishalfinteger-1"><code>ishalfinteger</code></a></h3><p>The function <code>ishalfinteger</code> can be used to check whether a number is equal to some half-integer:</p><pre><code class="language-julia-repl">julia&gt; ishalfinteger(0.5)
true

julia&gt; ishalfinteger(4)
true

julia&gt; ishalfinteger(1//3)
false</code></pre><h2><a class="nav-anchor" href="#Wraparound-behavior-1" id="Wraparound-behavior-1">Wraparound behavior</a></h2><p>Since the implementation of the <code>HalfInteger</code> type is based on the underlying integers (e.g., standard <code>Int</code> arithmetic in the case of the <code>HalfInt</code> type), <code>HalfInteger</code>s may be subject to <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Overflow-behavior-1">integer overflow</a>:</p><pre><code class="language-julia-repl">julia&gt; typemax(HalfInt64)
9223372036854775807/2

julia&gt; ans + onehalf(HalfInt64)
-4611686018427387904</code></pre><p>The behavior in the above example is due to <code>9223372036854775807 + 1 == -9223372036854775808</code>.</p><p>Overflows can also occur when converting an <code>Integer</code> to a <code>HalfInteger</code> type (which may happen implicitly due to promotion):</p><pre><code class="language-julia-repl">julia&gt; typemax(Int64)
9223372036854775807

julia&gt; HalfInt64(ans)  # 2 * 9223372036854775807 == -2
-1</code></pre><p>If you prefer checked arithmetic, you can use the <a href="https://github.com/JeffreySarnoff/SaferIntegers.jl">SaferIntegers</a> package:</p><pre><code class="language-julia-repl">julia&gt; using SaferIntegers

julia&gt; const SafeHalfInt64 = Half{SafeInt64}
Half{SafeInt64}

julia&gt; typemax(SafeHalfInt64)
9223372036854775807/2

julia&gt; ans + onehalf(SafeHalfInt64)
ERROR: OverflowError: 9223372036854775807 +y overflowed for type Int64</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Some <code>Half{&lt;:SafeInteger}</code> types require Julia ≥ 1.1 and SaferIntegers ≥ 2.2.1 to work correctly.</p></div></div><h2><a class="nav-anchor" href="#Custom-HalfInteger-types-1" id="Custom-HalfInteger-types-1">Custom <code>HalfInteger</code> types</a></h2><p>To implement a custom type <code>MyHalfInt &lt;: HalfInteger</code>, at least the following methods must be defined:</p><table><tbody><tr><th style="text-align: left">Required method</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><code>half(::Type{MyHalfInt}, x)</code></td><td style="text-align: left">Return <code>x/2</code> as a value of type <code>MyHalfInt</code></td></tr><tr><td style="text-align: left"><code>twice(x::MyHalfInt)</code></td><td style="text-align: left">Return <code>2x</code> as a value of some <code>Integer</code> type</td></tr></tbody></table><p>Thus, a simple implementation of a custom <code>HalfInteger</code> type may look like this:</p><pre><code class="language-julia">struct MyHalfInt &lt;: HalfInteger
    val::HalfInt
end

MyHalfInt(x::MyHalfInt) = x  # to avoid method ambiguity

HalfIntegers.half(::Type{MyHalfInt}, x) = MyHalfInt(half(HalfInt, x))

HalfIntegers.twice(x::MyHalfInt) = twice(x.val)</code></pre><p>The <code>MyHalfInt</code> type supports all arithmetic operations defined for <code>HalfInteger</code>s. However, some operations will return values of a <code>Half{T}</code> type, which may not be desirable:</p><pre><code class="language-julia-repl">julia&gt; MyHalfInt(3/2) + MyHalfInt(2)
7/2

julia&gt; typeof(ans)
Half{Int64}</code></pre><p>The following sections describe how to customize this behavior.</p><h3><a class="nav-anchor" href="#Customizing-arithmetic-operators-and-functions-1" id="Customizing-arithmetic-operators-and-functions-1">Customizing arithmetic operators and functions</a></h3><p>The operators/functions that return a <code>Half{T}</code> type are <code>+</code>, <code>-</code>, <code>mod</code> and <code>rem</code> (and other functions that make use of those, like <code>round</code>). If we want those operations to return <code>MyHalfInt</code>s, we can define the following methods (note that both one- and two-argument versions of <code>+</code> and <code>-</code> are defined):</p><pre><code class="language-julia">Base.:+(x::MyHalfInt) = x
Base.:+(x::MyHalfInt, y::MyHalfInt) = MyHalfInt(x.val + y.val)

Base.:-(x::MyHalfInt) = MyHalfInt(-x.val)
Base.:-(x::MyHalfInt, y::MyHalfInt) = MyHalfInt(x.val - y.val)

Base.mod(x::MyHalfInt, y::MyHalfInt) = MyHalfInt(mod(x.val, y.val))
Base.rem(x::MyHalfInt, y::MyHalfInt) = MyHalfInt(rem(x.val, y.val))</code></pre><p>Now, these arithmetic operations will return a <code>MyHalfInt</code> for <code>MyHalfInt</code> arguments. Certain operations will still yield other types:</p><ul><li><code>*</code> and <code>/</code> return floating-point numbers,</li><li><code>div</code>, <code>fld</code>, <code>cld</code> etc. return values of some <code>Integer</code> type.</li></ul><p>To change this behavior, we would need to define methods for these functions as well. For example, if we want our <code>MyHalfInt</code> type to return a <code>Rational</code> for multiplication and division, we could define the following methods:</p><pre><code class="language-julia">Base.:*(x::MyHalfInt, y::MyHalfInt) = twice(x)*twice(y)//4
Base.:/(x::MyHalfInt, y::MyHalfInt) = twice(x)//twice(y)</code></pre><h3><a class="nav-anchor" href="#Promotion-rules-1" id="Promotion-rules-1">Promotion rules</a></h3><p>In order to make mixed-type operations work with our <code>MyHalfInt</code> type, promotion rules need to be defined. As a simple example, we can define our <code>MyHalfInt</code> type to promote like <code>HalfInt</code> as follows:</p><pre><code class="language-julia">Base.promote_rule(::Type{MyHalfInt}, T::Type{&lt;:Real}) = promote_type(HalfInt, T)</code></pre><p>For more information on how to define promotion rules, cf. the <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/#Promotion-1">Julia documentation</a>.</p><h3><a class="nav-anchor" href="#Ranges-of-custom-HalfInteger-types-1" id="Ranges-of-custom-HalfInteger-types-1">Ranges of custom <code>HalfInteger</code> types</a></h3><p>Ranges of custom <code>HalfInteger</code> types should work out-of-the-box, but intersecting them may again yield ranges of <code>Half{T}</code> values:</p><pre><code class="language-julia-repl">julia&gt; a = MyHalfInt(3/2):MyHalfInt(3/2):MyHalfInt(15/2)
3/2:3/2:15/2

julia&gt; b = MyHalfInt(2):MyHalfInt(1):MyHalfInt(9)
2:1:9

julia&gt; intersect(a, b)
3:3:6

julia&gt; typeof(ans)
StepRange{Half{Int64},Half{Int64}}</code></pre><p>In order to change this behavior, custom methods for <code>Base.intersect</code> need to be defined as well.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API documentation</span></a></footer></article></body></HTML>